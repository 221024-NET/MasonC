/*global document window*/
const { Selector, ClientFunction }  = require('testcafe');

exports.ReactSelector = Selector(selector => {
    const getRootElsReact15     = /*global document*/

/*eslint-disable no-unused-vars*/
function getRootElsReact15 () {
    /*eslint-enable no-unused-vars*/

    const ELEMENT_NODE = 1;

    function getRootComponent (el) {
        if (!el || el.nodeType !== ELEMENT_NODE) return null;

        for (var prop of Object.keys(el)) {
            if (!/^__reactInternalInstance/.test(prop)) continue;

            return el[prop]._hostContainerInfo._topLevelWrapper._renderedComponent;
        }

        return null;
    }

    const rootEls      = [].slice.call(document.querySelectorAll('[data-reactroot]'));
    const checkRootEls = rootEls.length &&
                         Object.keys(rootEls[0]).some(prop => {
                             const rootEl = rootEls[0];

                             //NOTE: server rendering in React 16 also adds data-reactroot attribute, we check existing the
                             //alternate field because it doesn't exists in React 15.
                             return /^__reactInternalInstance/.test(prop) && !rootEl[prop].hasOwnProperty('alternate');
                         });

    return (checkRootEls && rootEls || []).map(getRootComponent);
}

    const getRootElsReact16to18 = /*global document*/

/*eslint-disable no-unused-vars*/
function getRootElsReact16to18 (el) {
    el = el || document.body;

    let rootEls = [];

    if (el._reactRootContainer) {
        const rootContainer = el._reactRootContainer._internalRoot || el._reactRootContainer;

        rootEls.push(rootContainer.current.child);
    }

    else {
        //NOTE: approach for React 18 createRoot API
        for (var prop of Object.keys(el)) {
            if (!/^__reactContainer/.test(prop)) continue;

            //NOTE: component and its alternate version has the same stateNode, but stateNode has the link to rendered version in the 'current' field
            const component = el[prop].stateNode.current;

            rootEls.push(component);

            break;
        }
    }

    const children = el.children;

    for (let index = 0; index < children.length; ++index) {
        const child = children[index];

        rootEls = rootEls.concat(getRootElsReact16to18(child));

    }

    return rootEls;
}

    const selectorReact15       = /*global window rootEls defineSelectorProperty visitedRootEls checkRootNodeVisited*/

/*eslint-disable no-unused-vars*/
function react15elector (selector, _, parents = rootEls) {
    const ELEMENT_NODE = 1;
    const COMMENT_NODE = 8;

    window['%testCafeReactFoundComponents%'] = [];

    const { getName, getRootComponent }  = window['%testCafeReactSelectorUtils%']['15'];

    function getRenderedChildren (component) {
        const hostNode        = component.getHostNode();
        const hostNodeType    = hostNode.nodeType;
        const container       = component._instance && component._instance.container;
        const isRootComponent = hostNode.hasAttribute && hostNode.hasAttribute('data-reactroot');

        //NOTE: prevent the repeating visiting of reactRoot Component inside of portal
        if (component._renderedComponent && isRootComponent) {
            if (checkRootNodeVisited(component._renderedComponent))
                return [];

            visitedRootEls.push(component._renderedComponent);
        }

        //NOTE: Detect if it's a portal component
        if (hostNodeType === COMMENT_NODE && container) {
            const domNode = container.querySelector('[data-reactroot]');

            return { _: getRootComponent(domNode) };
        }

        return component._renderedChildren ||
               component._renderedComponent &&
               { _: component._renderedComponent } ||
               {};
    }

    function parseSelectorElements (compositeSelector) {
        return compositeSelector
            .split(' ')
            .filter(el => !!el)
            .map(el => el.trim());
    }

    function reactSelect (compositeSelector) {
        const foundComponents = [];

        function findDOMNode (rootEl) {
            if (typeof compositeSelector !== 'string')
                throw new Error(`Selector option is expected to be a string, but it was ${typeof compositeSelector}.`);

            var selectorIndex = 0;
            var selectorElms  = parseSelectorElements(compositeSelector);

            if (selectorElms.length)
                defineSelectorProperty(selectorElms[selectorElms.length - 1]);

            function walk (reactComponent, cb) {
                if (!reactComponent) return;

                const componentWasFound = cb(reactComponent);

                //NOTE: we're looking for only between the children of component
                if (selectorIndex > 0 && selectorIndex < selectorElms.length && !componentWasFound) {
                    const isTag  = selectorElms[selectorIndex].toLowerCase() === selectorElms[selectorIndex];
                    const parent = reactComponent._hostParent;

                    if (isTag && parent) {
                        var renderedChildren       = parent._renderedChildren;
                        const renderedChildrenKeys = Object.keys(renderedChildren);

                        const currentElementId = renderedChildrenKeys.filter(key => {
                            var renderedComponent = renderedChildren[key]._renderedComponent;

                            return renderedComponent && renderedComponent._domID === reactComponent._domID;
                        })[0];

                        if (!renderedChildren[currentElementId])
                            return;
                    }
                }

                const currSelectorIndex = selectorIndex;

                renderedChildren = getRenderedChildren(reactComponent);


                Object.keys(renderedChildren).forEach(key => {
                    walk(renderedChildren[key], cb);

                    selectorIndex = currSelectorIndex;
                });
            }

            return walk(rootEl, reactComponent => {
                const componentName = getName(reactComponent);

                if (!componentName) return false;

                const domNode = reactComponent.getHostNode();

                if (selectorElms[selectorIndex] !== componentName) return false;

                if (selectorIndex === selectorElms.length - 1) {
                    if (foundComponents.indexOf(domNode) === -1)
                        foundComponents.push(domNode);

                    window['%testCafeReactFoundComponents%'].push({ node: domNode, component: reactComponent });
                }

                selectorIndex++;

                return true;
            });
        }

        [].forEach.call(parents, findDOMNode);

        return foundComponents;
    }

    return reactSelect(selector);
}

    const selectorReact16to18   = /*global window document Node rootEls defineSelectorProperty visitedRootEls checkRootNodeVisited*/

/*eslint-disable no-unused-vars*/
function react16to18Selector (selector, renderedRootIsUnknown, parents = rootEls) {
    window['%testCafeReactFoundComponents%'] = [];

    const { getRenderedComponentVersion }  = window['%testCafeReactSelectorUtils%']['16|17|18'];

    /*eslint-enable no-unused-vars*/
    function createAnnotationForEmptyComponent (component) {
        const comment = document.createComment('testcafe-react-selectors: the requested component didn\'t render any DOM elements');

        comment.__$$reactInstance = component;

        if (!window['%testCafeReactEmptyComponent%']) window['%testCafeReactEmptyComponent%'] = [];

        window['%testCafeReactEmptyComponent%'].push(comment);

        return comment;
    }

    function getName (component) {
        //react memo
        // it will find the displayName on the elementType if you set it
        if (component.elementType && component.elementType.displayName) return component.elementType.displayName;


        if (!component.type && !component.memoizedState)
            return null;

        const currentElement = component.type ? component : component.memoizedState.element;

        //NOTE: tag
        if (component.type) {
            if (typeof component.type === 'string') return component.type;
            if (component.type.displayName || component.type.name) return component.type.displayName || component.type.name;
        }

        const matches = currentElement.type.toString().match(/^function\s*([^\s(]+)/);

        if (matches) return matches[1];

        return null;
    }

    function findNodeWithStateNodeInChildrenOrSiblings (searchNode) {
        const nodesToCheck = [];

        nodesToCheck.push(searchNode);
        while (nodesToCheck.length > 0) {
            const node = nodesToCheck.shift();

            if (node.stateNode instanceof Node) return node;
            if (node.child) nodesToCheck.push(node.child);
            if (node.sibling && node !== searchNode) nodesToCheck.push(node.sibling);
        }
        return searchNode;
    }

    function getContainer (component) {
        let node = renderedRootIsUnknown ? getRenderedComponentVersion(component) : component;

        node = findNodeWithStateNodeInChildrenOrSiblings(node);

        if (!(node.stateNode instanceof Node))
            return null;

        return node.stateNode;
    }

    function getRenderedChildren (component) {
        const isRootComponent = rootEls.indexOf(component) > -1;

        //Nested root element
        if (isRootComponent) {
            if (checkRootNodeVisited(component)) return [];

            visitedRootEls.push(component);
        }

        //Portal component
        if (!component.child) {
            const portalRoot = component.stateNode && component.stateNode.container &&
                               component.stateNode.container._reactRootContainer;

            const rootContainer = portalRoot && (portalRoot._internalRoot || portalRoot);

            if (rootContainer) component = rootContainer.current;
        }

        if (!component.child) return [];

        let currentChild = component.child;

        if (typeof component.type !== 'string')
            currentChild = component.child;

        const children = [currentChild];

        while (currentChild.sibling) {
            children.push(currentChild.sibling);

            currentChild = currentChild.sibling;
        }

        return children;
    }

    function parseSelectorElements (compositeSelector) {
        return compositeSelector
            .split(' ')
            .filter(el => !!el)
            .map(el => el.trim());
    }

    function reactSelect (compositeSelector) {
        const foundComponents = [];

        function findDOMNode (rootComponent) {
            if (typeof compositeSelector !== 'string')
                throw new Error(`Selector option is expected to be a string, but it was ${typeof compositeSelector}.`);

            var selectorIndex = 0;
            var selectorElms  = parseSelectorElements(compositeSelector);

            if (selectorElms.length)
                defineSelectorProperty(selectorElms[selectorElms.length - 1]);

            function walk (reactComponent, cb) {
                if (!reactComponent) return;

                const componentWasFound = cb(reactComponent);
                const currSelectorIndex = selectorIndex;

                const isNotFirstSelectorPart = selectorIndex > 0 && selectorIndex < selectorElms.length;

                if (isNotFirstSelectorPart && !componentWasFound) {
                    const isTag = selectorElms[selectorIndex].toLowerCase() === selectorElms[selectorIndex];

                    //NOTE: we're looking for only between the children of component
                    if (isTag && getName(reactComponent.return) !== selectorElms[selectorIndex - 1])
                        return;
                }

                const renderedChildren = getRenderedChildren(reactComponent);

                Object.keys(renderedChildren).forEach(key => {
                    walk(renderedChildren[key], cb);

                    selectorIndex = currSelectorIndex;
                });
            }

            return walk(rootComponent, reactComponent => {
                const componentName = getName(reactComponent);

                if (!componentName) return false;

                const domNode = getContainer(reactComponent);

                if (selectorElms[selectorIndex] !== componentName) return false;

                if (selectorIndex === selectorElms.length - 1) {
                    if (foundComponents.indexOf(domNode) === -1)
                        foundComponents.push(domNode || createAnnotationForEmptyComponent(reactComponent));

                    window['%testCafeReactFoundComponents%'].push({ node: domNode, component: reactComponent });
                }

                selectorIndex++;

                return true;
            });
        }

        [].forEach.call(parents, findDOMNode);

        return foundComponents;
    }

    return reactSelect(selector);
}


    let visitedRootEls = [];
    let rootEls        = null;

    function checkRootNodeVisited (component) {
        return visitedRootEls.indexOf(component) > -1;
    }

    function defineSelectorProperty (value) {
        if (window['%testCafeReactSelector%']) delete window['%testCafeReactSelector%'];

        Object.defineProperty(window, '%testCafeReactSelector%', {
            enumerable:   false,
            configurable: true,
            writable:     false,
            value:        value
        });
    }

    const react15Utils     = /*global window*/
(function () {
    const ELEMENT_NODE = 1;
    const COMMENT_NODE = 8;

    /*eslint-enable no-unused-vars*/
    function getName (component) {
        const currentElement = component._currentElement;

        let name = component.getName ? component.getName() : component._tag;

        //NOTE: getName() returns null in IE, also it try to get function name for a stateless component
        if (name === null && currentElement && typeof currentElement === 'object') {
            const matches = currentElement.type.toString().match(/^function\s*([^\s(]+)/);

            if (matches) name = matches[1];
        }

        return name;
    }

    function getRootComponent (el) {
        if (!el || el.nodeType !== ELEMENT_NODE) return null;

        for (var prop of Object.keys(el)) {
            if (!/^__reactInternalInstance/.test(prop)) continue;

            return el[prop]._hostContainerInfo._topLevelWrapper._renderedComponent;
        }

        return null;
    }

    function copyReactObject (obj) {
        var copiedObj = {};

        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && prop !== 'children')
                copiedObj[prop] = obj[prop];
        }

        return copiedObj;
    }

    function getComponentInstance (component) {
        const parent               = component._hostParent || component;
        const renderedChildren     = parent._renderedChildren || { _: component._renderedComponent } || {};
        const renderedChildrenKeys = Object.keys(renderedChildren);
        const componentName        = window['%testCafeReactSelector%'];

        for (let index = 0; index < renderedChildrenKeys.length; ++index) {
            const key             = renderedChildrenKeys[index];
            let renderedComponent = renderedChildren[key];
            let componentInstance = null;

            while (renderedComponent) {
                if (componentName === getName(renderedComponent))
                    componentInstance = renderedComponent._instance || renderedComponent._currentElement;

                if (renderedComponent._domID === component._domID)
                    return componentInstance;

                renderedComponent = renderedComponent._renderedComponent;
            }
        }

        return null;
    }

    function getComponentForDOMNode (el) {
        if (!el || !(el.nodeType === ELEMENT_NODE || el.nodeType === COMMENT_NODE))
            return null;

        const isRootNode    = el.hasAttribute && el.hasAttribute('data-reactroot');
        const componentName = window['%testCafeReactSelector%'];

        if (isRootNode) {
            const rootComponent = getRootComponent(el);

            //NOTE: check if it's not a portal component
            if (getName(rootComponent) === componentName)
                return rootComponent._instance;

            return getComponentInstance(rootComponent);
        }

        for (var prop of Object.keys(el)) {
            if (!/^__reactInternalInstance/.test(prop))
                continue;

            return getComponentInstance(el[prop]);
        }

        return null;
    }

    function getComponentKey (component) {
        const currentElement = component._reactInternalInstance ? component._reactInternalInstance._currentElement : component;

        return currentElement.key;
    }

    /*eslint-disable no-unused-vars*/
    function getReact (node, fn) {
        /*eslint-enable no-unused-vars*/
        const componentInstance = getComponentForDOMNode(node);

        if (!componentInstance) return null;

        delete window['%testCafeReactSelector%'];

        if (typeof fn === 'function') {
            return fn({
                state: copyReactObject(componentInstance.state),
                props: copyReactObject(componentInstance.props),
                key:   getComponentKey(componentInstance)
            });
        }

        return {
            state: copyReactObject(componentInstance.state),
            props: copyReactObject(componentInstance.props),
            key:   getComponentKey(componentInstance)
        };
    }

    function getFoundComponentInstances () {
        return window['%testCafeReactFoundComponents%'].map(desc => desc.component);
    }

    function scanDOMNodeForReactComponent (el) {
        if (!el || !(el.nodeType === ELEMENT_NODE || el.nodeType === COMMENT_NODE))
            return null;

        let component = null;

        for (const prop of Object.keys(el)) {
            if (!/^__reactInternalInstance/.test(prop))
                continue;

            component = el[prop];

            break;
        }

        if (!component) return null;

        const parent = component._hostParent;

        if (!parent) return component;

        const renderedChildren     = parent._renderedChildren;
        const renderedChildrenKeys = Object.keys(renderedChildren);

        const currentElementId = renderedChildrenKeys.filter(key => {
            const renderedComponent = renderedChildren[key];

            return renderedComponent && renderedComponent.getHostNode() === el;
        })[0];

        return renderedChildren[currentElementId];
    }

    return {
        getReact,
        getComponentForDOMNode,
        scanDOMNodeForReactComponent,
        getFoundComponentInstances,
        getComponentKey,
        getName,
        getRootComponent
    };
})();


    const react16to18Utils = /*global window Node*/
(function () {
    const ELEMENT_NODE = 1;
    const COMMENT_NODE = 8;

    //https://github.com/facebook/react/commit/2ba43edc2675380a0f2222f351475bf9d750c6a9
    //__reactInternalInstance - react 16
    //__reactFiber - react 17
    const REACT_INTERNAL_INSTANCE_PROP_RE = /^__reactInternalInstance|^__reactFiber/;

    function copyReactObject (obj) {
        var copiedObj = {};

        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && prop !== 'children')
                copiedObj[prop] = obj[prop];
        }

        return copiedObj;
    }

    function getComponentForDOMNode (el) {
        if (!el || !(el.nodeType === ELEMENT_NODE || el.nodeType === COMMENT_NODE)) return null;

        let component             = null;
        const emptyComponentFound = window['%testCafeReactEmptyComponent%'] &&
                                    window['%testCafeReactEmptyComponent%'].length;

        if (emptyComponentFound && el.nodeType === COMMENT_NODE)
            component = window['%testCafeReactEmptyComponent%'].shift().__$$reactInstance;

        else if (window['%testCafeReactFoundComponents%'].length)
            component = window['%testCafeReactFoundComponents%'].filter(desc => desc.node === el)[0].component;

        const props = component.stateNode && component.stateNode.props || component.memoizedProps;
        const state = component.stateNode && component.stateNode.state || component.memoizedState;
        const key   = component.key;

        return { props, state, key };
    }

    /*eslint-enable no-unused-vars*/
    function getReact (node, fn) {
        /*eslint-disable no-unused-vars*/
        const componentInstance = getComponentForDOMNode(node);

        if (!componentInstance) return null;

        delete window['%testCafeReactSelector%'];
        delete window['%testCafeReactEmptyComponent%'];
        delete window['%testCafeReactFoundComponents%'];

        if (typeof fn === 'function') {
            return fn({
                state: copyReactObject(componentInstance.state),
                props: copyReactObject(componentInstance.props),
                key:   componentInstance.key
            });
        }

        return {
            state: copyReactObject(componentInstance.state),
            props: copyReactObject(componentInstance.props),
            key:   componentInstance.key
        };
    }

    function scanDOMNodeForReactInstance (el) {
        if (!el || !(el.nodeType === ELEMENT_NODE || el.nodeType === COMMENT_NODE)) return null;

        if (el.nodeType === COMMENT_NODE) 
            return el.__$$reactInstance.return.child;

        for (var prop of Object.keys(el)) {
            if (!REACT_INTERNAL_INSTANCE_PROP_RE.test(prop)) continue;

            let nestedComponent = el[prop];

            if (typeof nestedComponent.type !== 'string')
                return nestedComponent;

            let parentComponent = nestedComponent;

            do {
                nestedComponent = parentComponent;
                parentComponent = nestedComponent.return;
            } while (parentComponent && parentComponent.type && !(parentComponent.stateNode instanceof Node));

            return nestedComponent;
        }

        return null;
    }

    function getRenderedComponentVersion (component) {        
        const rootContainers = window['$testCafeReact16to18RootContainers'];
        
        if (!component.alternate) return component;

        let component1 = component;
        let component2 = component.alternate;

        while (component1.return) component1 = component1.return;
        while (component2.return) component2 = component2.return;
        
        if (rootContainers.indexOf(component1) > -1) return component;

        return component.alternate;
    }

    function scanDOMNodeForReactComponent (domNode) {
        const rootInstances = window['$testCafeReact16to18Roots'].map(rootEl => rootEl.return || rootEl);
        const reactInstance = scanDOMNodeForReactInstance(domNode);

        return getRenderedComponentVersion(reactInstance);
    }

    function getFoundComponentInstances () {
        return window['%testCafeReactFoundComponents%'].map(desc => desc.component);
    }

    function getComponentKey (instance) {
        return instance.key;
    }

    return { getReact, getComponentForDOMNode, scanDOMNodeForReactComponent, getFoundComponentInstances, getComponentKey, getRenderedComponentVersion };
})();


    if(!window['%testCafeReactSelectorUtils%']) {
        window['%testCafeReactSelectorUtils%'] = {
            '15'   : react15Utils,
            '16|17|18': react16to18Utils
        };
    }

    rootEls = getRootElsReact15();

    let foundDOMNodes = void 0;

    if(rootEls.length) {
        window['%testCafeReactVersion%'] = '15';
        window['$testCafeReactSelector'] = selectorReact15;

        foundDOMNodes = selectorReact15(selector);
    }

    rootEls = getRootElsReact16to18();

    if(rootEls.length) {
        //NOTE: root.return for 16 and 17 version
        const rootContainers = rootEls.map(root => root.return || root);

        window['%testCafeReactVersion%']             = '16|17|18';
        window['$testCafeReactSelector']             = selectorReact16to18;
        window['$testCafeReact16to18Roots']          = rootEls;
        window['$testCafeReact16to18RootContainers'] = rootContainers;


        foundDOMNodes = selectorReact16to18(selector, false);
    }

    visitedRootEls = [];

    if(foundDOMNodes)
        return foundDOMNodes;

    throw new Error("React component tree is not loaded yet or the current React version is not supported. This module supports React version 16.x and newer. To wait until the React's component tree is loaded, add the `waitForReact` method to fixture's `beforeEach` hook.");
}).addCustomMethods({
    getReact: (node, fn) => {
        const reactVersion = window['%testCafeReactVersion%'];
        const reactUtils   = window['%testCafeReactSelectorUtils%'][reactVersion];

        delete window['%testCafeReactVersion%'];

        return reactUtils.getReact(node, fn);
    }
}).addCustomMethods({
    withProps: (nodes, ...args) => {
        window['%testCafeReactFoundComponents%'] = window['%testCafeReactFoundComponents%'].filter(component => {
            return nodes.indexOf(component.node) > -1;
        });

        function isObject(value) {
            return typeof value === 'object' && value !== null && !Array.isArray(value);
        }

        function isEql (value1, value2) {
            if (typeof value1 !== 'object' || value1 === null || typeof value2 !== 'object' || value2 === null)
                return value1 === value2;

            if (Object.keys(value1).length !== Object.keys(value2).length)
                return false;

            for (const prop in value1) {
                if (!value2.hasOwnProperty(prop)) return false;
                if (!isEql(value1[prop], value2[prop])) return false;
            }

            return true;
        }

        function isInclude (value1, value2) {
            if (typeof value1 !== 'object' || value1 === null || typeof value2 !== 'object' || value2 === null)
                return value1 === value2;

            for (const prop in value2) {
                if (!value1.hasOwnProperty(prop)) return false;
                if (!isInclude(value1[prop], value2[prop])) return false;
            }

            return true;
        }

        function matchProps(value1, value2, exactObjectMatch) {
            if(exactObjectMatch) return isEql(value1, value2);

            return isInclude(value1, value2);
        }

        function componentHasProps ({ props }, filterProps, exactObjectMatch) {
             for (const prop of Object.keys(filterProps)) {
                 if (!props.hasOwnProperty(prop)) return false;

                 if (!matchProps(props[prop], filterProps[prop], exactObjectMatch))
                     return false;
             }

             return true;
        }

        const reactVersion = window['%testCafeReactVersion%'];
        let filterProps    = {};
        let options        = null;

        const firstArgsIsObject = isObject(args[0]);

        if (args.length === 2 && firstArgsIsObject)
            options = args[1];

        else if (args.length > 2)
            options = args[2];

        if(args.length < 2 && !firstArgsIsObject)
             throw new Error(`The "props" option value is expected to be a non-null object, but it is ${typeof args[0]}.`);
        else if(typeof args[0] !== 'string' && !firstArgsIsObject)
            throw new Error(`The first argument is expected to be a property name string or a "props" non-null object, but it is ${typeof args[0]}.`);

        if(options && typeof options !== 'object' && !Array.isArray(args[0]))
            throw new Error(`The "options" value is expected to be an object, but it is ${typeof options}.`);

        if (args.length > 1) {
            if(firstArgsIsObject)
                filterProps = args[0];
            else
                filterProps[args[0]] = args[1];
        }

        else if (args[0]) filterProps = args[0];

        let getComponentForDOMNode = window['%testCafeReactSelectorUtils%'][reactVersion].getComponentForDOMNode;

        const filteredNodes  = [];
        const exactObjectMatch = options && options.exactObjectMatch || false;

        const foundInstances = nodes.filter(node => {
             const componentInstance = getComponentForDOMNode(node);

             if(componentInstance && componentHasProps(componentInstance, filterProps, exactObjectMatch)) {
                 filteredNodes.push(node);

                 return true;
             }
        });

        return foundInstances;
    },

    withKey: (nodes, key) => {
        if(key === void 0 || key === null) return [];

        const keyString = key.toString();

        window['%testCafeReactFoundComponents%'] = window['%testCafeReactFoundComponents%'].filter(component => {
            return nodes.indexOf(component.node) > -1;
        });

        const reactVersion     = window['%testCafeReactVersion%'];
        const reactUtils       = window['%testCafeReactSelectorUtils%'][reactVersion];

        let getComponentForDOMNode = reactUtils.getComponentForDOMNode;
        let getComponentKey        = reactUtils.getComponentKey;

        const filteredNodes  = [];

        const foundInstances = nodes.filter(node => {
            const componentInstance = getComponentForDOMNode(node);
            const componentKey      = getComponentKey(componentInstance);

            if(componentInstance && componentKey === keyString) {
                filteredNodes.push(node);

                return true;
            }
        });

        return foundInstances;
    },

    findReact: (nodes, selector) => {
        const reactVersion = window['%testCafeReactVersion%'];
        const reactUtils   = window['%testCafeReactSelectorUtils%'][reactVersion];

        let componentInstances           = null;
        let scanDOMNodeForReactComponent = reactUtils.scanDOMNodeForReactComponent;

        componentInstances = nodes.map(scanDOMNodeForReactComponent);

        const reactSelector = window['$testCafeReactSelector'];

        return reactSelector(selector, true, componentInstances);
    }
}, { returnDOMNodes: true });

exports.waitForReact = /*global ClientFunction document NodeFilter*/

/*eslint-disable no-unused-vars*/
function waitForReact (timeout, testController) {
    /*eslint-enable no-unused-vars*/
    const DEFAULT_TIMEOUT = 1e4;
    const checkTimeout    = typeof timeout === 'number' ? timeout : DEFAULT_TIMEOUT;

    return ClientFunction(() => {
        const CHECK_INTERVAL = 200;
        let stopChecking     = false;

        function findReact16to18Root () {
            const treeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);

            while (treeWalker.nextNode()) {
                //NOTE: fast check for 16 and 17 react
                if (treeWalker.currentNode.hasOwnProperty('_reactRootContainer')) return true;

                //NOTE: react 18
                for (const prop of Object.keys(treeWalker.currentNode))
                    if (/^__reactContainer/.test(prop)) return true;
            }

            return false;
        }

        function findReact15OrStaticRenderedRoot () {
            const rootEl = document.querySelector('[data-reactroot]');

            //NOTE: we have data-reactroot in static render even before hydration
            return rootEl && Object.keys(rootEl).some(prop => /^__reactInternalInstance/.test(prop));
        }

        function findReactApp () {
            const isReact15OrStaticRender = findReact15OrStaticRenderedRoot();
            const isReact16to18WithHandlers   = !!Object.keys(document).filter(prop => /^_reactListenersID|^_reactEvents/.test(prop)).length;

            return isReact15OrStaticRender || isReact16to18WithHandlers || findReact16to18Root();
        }

        return new Promise((resolve, reject) => {
            function tryFindReactApp () {
                const startTime        = new Date();
                const reactTreeIsFound = findReactApp();
                const checkTime        = new Date() - startTime;

                if (reactTreeIsFound) {
                    resolve();
                    return;
                }

                if (stopChecking) return;

                setTimeout(tryFindReactApp, checkTime > CHECK_INTERVAL ? checkTime : CHECK_INTERVAL);
            }

            tryFindReactApp();

            setTimeout(() => {
                stopChecking = true;

                reject('waitForReact: The waiting timeout is exceeded');
            }, checkTimeout);
        });
    }, { dependencies: { checkTimeout }, boundTestRun: testController })();
}
;
