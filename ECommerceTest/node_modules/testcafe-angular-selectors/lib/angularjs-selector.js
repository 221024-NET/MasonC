'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*global window*/

var _testcafe = require('testcafe');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AngularJSSelector = function () {
    function AngularJSSelector() {
        _classCallCheck(this, AngularJSSelector);

        var getComparer = (0, _testcafe.ClientFunction)(function (exactMatch) {
            var strictComparer = function strictComparer(item1, item2) {
                return item1 === item2;
            };
            var containsComparer = function containsComparer(item1, item2) {
                return item1.indexOf(item2) !== -1;
            };

            return exactMatch ? strictComparer : containsComparer;
        });

        var testNodeForAngularAttr = (0, _testcafe.ClientFunction)(function (node, attrSuffix) {
            var ANGULAR_ATTR_PREFIXES = ['ng-', 'ng_', 'data-ng-', 'x-ng-', 'ng\\:'];
            var result = {
                hasAttr: false
            };

            for (var i = 0; i < ANGULAR_ATTR_PREFIXES.length; i++) {
                var prefix = ANGULAR_ATTR_PREFIXES[i];
                var attrName = prefix + attrSuffix;

                if (node.hasAttribute && node.hasAttribute(attrName)) {
                    result.attrName = attrName;
                    result.hasAttr = true;
                    break;
                }
            }

            return result;
        });

        var ensureParent = function ensureParent(parentSelector) {
            return parentSelector || (0, _testcafe.Selector)(function () {
                return document.documentElement;
            });
        };

        this._findByBinding = function (expression, parentSelector, exactMatch) {
            var parent = ensureParent(parentSelector);
            var dependencies = { getComparer, exactMatch, expression };
            var filter = (0, _testcafe.ClientFunction)(function (node) {
                var dataBinding = window.angular.element(node).data('$binding');

                if (!dataBinding) return false;

                var bindingNameArr = dataBinding.exp || dataBinding[0].exp || dataBinding;
                var bindingName = Array.isArray(bindingNameArr) ? bindingNameArr[0] : bindingNameArr;
                var comparer = getComparer(exactMatch);

                return comparer(bindingName, expression);
            });

            return parent.find('.ng-binding').filter(filter, dependencies);
        };

        this._findByAngularAttr = function (name, value, parentSelector, exactMatch) {
            var parent = ensureParent(parentSelector);
            var dependencies = { getComparer, testNodeForAngularAttr, exactMatch, name, value };
            var filter = (0, _testcafe.ClientFunction)(function (node) {
                var result = testNodeForAngularAttr(node, name);

                if (!result.hasAttr) return false;

                var bindingAttrValue = node.getAttribute(result.attrName) || '';
                var comparer = getComparer(exactMatch);

                return comparer(bindingAttrValue, value);
            });

            return parent.find(filter, dependencies);
        };
    }

    _createClass(AngularJSSelector, [{
        key: '_assertNonEmptyStringParameter',
        value: function _assertNonEmptyStringParameter(_ref) {
            var paramShortDescription = _ref.paramShortDescription,
                paramValue = _ref.paramValue;

            if (typeof paramValue !== 'string' || !paramValue) throw new Error(`"${paramShortDescription}" parameter should be a non-empty string`);
        }
    }, {
        key: 'byBinding',
        value: function byBinding(bindingDescriptor, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Binding expression',
                paramValue: bindingDescriptor
            });

            return this._findByBinding(bindingDescriptor, parentSelector);
        }
    }, {
        key: 'byExactBinding',
        value: function byExactBinding(bindingDescriptor, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Binding expression',
                paramValue: bindingDescriptor
            });

            return this._findByBinding(bindingDescriptor, parentSelector, true);
        }
    }, {
        key: 'byModel',
        value: function byModel(model, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Model expression',
                paramValue: model
            });

            return this._findByAngularAttr('model', model, parentSelector, true);
        }
    }, {
        key: 'byOptions',
        value: function byOptions(optionsDescriptor, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Options expression',
                paramValue: optionsDescriptor
            });

            return this._findByAngularAttr('options', optionsDescriptor, parentSelector, true);
        }
    }, {
        key: 'byRepeater',
        value: function byRepeater(repeatDescriptor, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Repeat expression',
                paramValue: repeatDescriptor
            });

            return this._findByAngularAttr('repeat', repeatDescriptor, parentSelector);
        }
    }, {
        key: 'byExactRepeater',
        value: function byExactRepeater(repeatDescriptor, parentSelector) {
            this._assertNonEmptyStringParameter({
                paramShortDescription: 'Repeat expression',
                paramValue: repeatDescriptor
            });

            return this._findByAngularAttr('repeat', repeatDescriptor, parentSelector, true);
        }
    }]);

    return AngularJSSelector;
}();

exports.default = new AngularJSSelector();